<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>Algoritmos back tracking & greedy</title>
	<link href="style.css" rel="stylesheet" type="text/css" />
  <style type="text/css">
    th,td{
      width:50%
    }
  </style>
	<script src="./p3_backGreedy.js" type="module"></script>

	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

	<!-- https://www.npmjs.com/package/pseudocode -->
	<script>
		MathJax = {
        tex: {
            inlineMath: [['$','$'], ['\\(','\\)']],
            displayMath: [['$$','$$'], ['\\[','\\]']],
            processEscapes: true,
            processEnvironments: true,
        }
    }
	</script>
	<script src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/tex-chtml.js" integrity="sha256-3Fdoa5wQb+JYfEmTpQHx9sc/GuwpfC/0R9EpBki+mf8="
	 crossorigin>

	</script>
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.css">
	<script src="https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.js">

	</script>
</head>

<body>
	<h1>Algoritmos backtracking & greedy</h1>
	<br>
  <p>Aquí se encuentran algoritmos que resuelven problemas usando back tracking o de forma greedy (glotona). Los tiempos de ejecución aparecen muy ligeramente modificados por usar fúnciones "<a href="https://web.archive.org/web/20201112021653/https://en.wikipedia.org/wiki/Wrapper_function">wrapper</a>".</p>
  <div class="toc_container">
    <h2 class="toc_title">Índice</h2>
    <ol class="toc">
      <li><a href="#backtrack">Backtracking</a>
        <ol>
          <li><a href="#nqueen">N reinas recursivo</a></li>
        </ol>
      </li>
      <li><a href="#greedy">Greedy</a>
        <ol>
          <li><a href="#huffman">Códigos de Huffman</a></li>
          <li><a href="#select">Selector de actividades</a></li>
        </ol>
      </li>
    </ol>
  </div>
	<br><!-- ++++++++++++++++++++++++++++++++++++++++++++++++++ -->

  
  <div class="divSeparator"></div>
  <h2 id="backtrack">Backtracking</h2>
  <p>Los algoritmos backtracking buscan todas las posibles formas de actuar en un problema con tal de encontrar una solución. Son efectivos pero en problemas grandes se vuelven demasiado lentos.</p>
  <!-- +++++++ -->
  <div class="divSeparator"></div>
  <h3 id="nqueen">Algoritmo solucion del problema de n reinas  <button onclick="hideShow('div_nqueen',this)" class="buttSpoiler">[ Ocultar ]</button></h3>
  <div id="div_nqueen">
    <p>Este es un problema clásico de backtracking, consiste en colocar \( n \) cantidad reinas de ajedrez en un tablero de \( n \) filas y \( n \) columnas, tal que ninguna reina ataque a otra, esto es que no se encuentren en la misma fila, columna o diagonal.</p>
    <h4>Descripción del algoritmo</h4>
    <p>Busca una solucion valida para el problema de las n reinas. Tiene tiempo de ejecución exponencial.</p>

    <h4>Pseudocódigo</h4>
    <img src="./i3_backGreedy/recursivenqueens.PNG" style="width:80%">
    <p>Código de (Erickson, 2019).</p>

    <h4>Fuente bibliográfica</h4>
    <p>Erickson, J. (2019). <em>Algorithms</em> (p.73). http://algorithms.wtf</p>

    <h4>Implementación</h4>
    <p>Realizada en Javascript. Valores grandes de n pueden alentar.</p>
    <b>Entrada:</b>
    <p>El número \( n \) de renglones y columnas de la tabla \( n*n \).<b>Nota: n mayor a 13 es muy lento.</b></p>
    n = <input type="text" id="entry_nQueen" value="4" size="2" maxlength="4"> 
    <button onclick="runFunc('ans_nQueen','delay_nQueen','nQueens','entry_nQueen')" >Correr</button>
    <br>
    <br>
    <b>Salida:</b>
    <p>Todas las posibles respuestas en forma lista con las posiciones de las reinas, donde el número representa la columna (iniciando desde 0) y la posicion en la lista el renglon.
    <br> Y tiempo de ejecución del algoritmo, sin contar llamadas u operaciones extras en JavaScript (excepto por el wrapper que usa la funcion, pero deberia valer casi constante junto con la impresion de respuestas).<p>
    <p>\( Soluciones:\; \)</p>
    <textarea id="ans_nQueen" rows="8" cols="45" style="width: 80%" disabled=true>
      Esperando...
    </textarea>
    <div id="delay_nQueen"></div>
  </div>

  
  <div class="divSeparator"></div>
  <h2 id="greedy">Greedy</h2>
  <p>Los algoritmos greedy siempre seleccionan la mejor opción en cada paso, o la que parece ser, logrando soluciones optimas locales, pero no siempre son globales.</p>
  
  <!-- +++++++ -->
  <div class="divSeparator"></div>
  <h3 id="huffman">Códigos de Huffman  <button onclick="hideShow('div_huffman',this)" class="buttSpoiler">[ Ocultar ]</button></h3>
  <div id="div_huffman">
    <p>En un problema donde se tiene una cierte cantidad de caracteres y cada letra tiene su frecuencia, de que manera se puede usar menos bits para diferenciar y almacenar las todos los caraccteres.</p>
    <h4>Descripción del algoritmo</h4>
    <p>Busca una solucion optima para el planteamiento de huffman según unos caracteres. Tiene tiempo de ejecución \( T(n) = O( n \lg n) \).</p>

    <h4>Pseudocódigo</h4>
    <img src="./i3_backGreedy/huffman.PNG" style="width:80%">
    <p>Código de (Cormen, 2001).</p>

    <h4>Fuente bibliográfica</h4>
    <p>Thomas H. Cormen, C. (2001). <em>Introduction to algorithms</em> (p. 431). The MIT Press.</p>

    <h4>Implementación</h4>
    <p>Realizada en Javascript. Se usó una estructura de arbol ya que el valor regresado en pseudocódigo original descarta todo el acomodo hecho en Q para identificar el arbol construido. Si bien es valido con listas y otras modificaciones aun asi no se pierde mucha velocidad ya que los objetos se pasan por referencia en donde más se repiten, o el proceso de copia es constante.</p>
    <b>Entrada:</b>
    <p>El conjunto ordenado \( C \) de \(n \) caracteres, donde cada carácter \( c \in C \) tiene un atributo frecuencia (se ordena con la frecuencia de menor a mayor). Separados por coma cada par "caracter:frecuencia".<b>Nota: .</b></p>
    Lista = <textarea id="entry_huffman" rows="8" cols="45" style="width: 100%">f:5,e:9,c:12,b:13,d:16,a:45</textarea>
    <!-- f:5000,e:9000,d:16000,c:12000,b:13000,a:45000 -->
    <button onclick="runFunc('ans_huffman','delay_huffman','huffman','entry_huffman')" >Correr</button>
    <br>
    <br>
    <b>Salida:</b>
    <p>Tamaño de almacenamiento mas chico de 0s y 1s obtenido por algoritmo Greedy.
    <br> Y tiempo de ejecución del algoritmo, sin contar llamadas u operaciones extras en JavaScript (excepto por el wrapper que usa la funcion, pero deberia valer casi constante junto con la impresion de respuestas).<p>
    <p>\( Tamaño:\; \) <b id="ans_huffman"></b></p>
    <div id="delay_huffman"></div>
  </div>

  <!-- +++++++ -->
  <div class="divSeparator"></div>
  <h3 id="select">Selector de actividades  <button onclick="hideShow('div_selectAct',this)" class="buttSpoiler">[ Ocultar ]</button></h3>
  <div id="div_selectAct">
    <p>En el problema de programar actividades que requieren el uso de un recurso en común, la meta es seleccionar el mayor número de actividades mutuamente compatibles.</p>
    <table align="center" id="tab_fact">
      <tr>
        <th><h3>Recursivo<h3></th>
        <th><h3>Iterativo<h3></th>
      </tr>
      <tr>
        <td>
          <h4>Descripción del algoritmo</h4>
          <p>Este algoritmo encuentra la mayor cantidad de actividades compatibles posibles de forma recursiva. Tiene tiempo de ejecución: \( T(n) = \Theta (n) \).</p>

          <h4>Pseudocódigo</h4>
          <img src="./i3_backGreedy/recursiveActSelector.PNG" style="width:90%">
          <p>Código de (Cormen, 2001).</p>

          <h4>Fuente bibliográfica</h4>
          <p>Thomas H. Cormen, C. (2001). <em>Introduction to algorithms</em> (p. 419). The MIT Press.</p>

          <h4>Implementación</h4>
          <p>Realizada en Javascript.</p>
          <b>Entrada:</b>
          <p>Recibe 2 listas con los horarios de actividades (iniciando desde la actividad 0), donde \( S \) son los horarios de inicio y \( F \) los de finalizacion. Escriba las mismas actividades en misma posicion de la lista <b>Nota: \( F \) debe estar ordenado de menor a mayor.</b></p>
          <p>
          \( S \) = <textarea id="entry_SactSelect_R" rows="1" cols="45" style="width: 90%">1,3,0,5,3,5,6,8,8,2,12</textarea>
           <br>
          \( F \) = <textarea id="entry_FactSelect_R" rows="1" cols="45" style="width: 90%">4,5,6,7,8,9,10,11,12,13,14</textarea>
          </p>
          <button onclick="runFunc('ans_actSelect_R','delay_actSelect_R','actSelect_R','entry_SactSelect_R','entry_FactSelect_R')" >Correr</button>
          <br>
          <br>
          <b>Salida:</b>
          <p>Conjunto más grande \( A \) de actividades compatibles.<br> Y tiempo de ejecución del algoritmo, sin contar llamadas u operaciones extras en JavaScript, excepto por el wrapper.<p>
          \( A: \; \)<b id="ans_actSelect_R"></b>
          <div id="delay_actSelect_R"></div>
        </td><!-- ******************************************************** -->
        <td>
          <h4>Descripción del algoritmo</h4>
          <p>Este algoritmo encuentra la mayor cantidad de actividades compatibles posibles de forma iterativa. Tiene tiempo de ejecución: \( T(n) = \Theta (n) \)</p>

          <h4>Pseudocódigo</h4>
          <img src="./i3_backGreedy/greedyActSelector.PNG" style="width:80%">
          <p>Código de (Cormen, 2001).</p>

          <h4>Fuente bibliográfica</h4>
          <p>Thomas H. Cormen, C. (2001). <em>Introduction to algorithms</em> (p. 421). The MIT Press.</p>

          <h4>Implementación</h4>
          <p>Realizada en Javascript.</p>
          <b>Entrada:</b>
          <p>Recibe 2 listas con los horarios de actividades  (iniciando desde la actividad 0), donde \( S \) son los horarios de inicio y \( F \) los de finalizacion. Escriba las mismas actividades en misma posicion de la lista <b>Nota: \( F \) debe estar ordenado de menor a mayor.</b></p>
          <p>
          \( S \) = <textarea id="entry_SactSelect_I" rows="1" cols="45" style="width: 90%">1,3,0,5,3,5,6,8,8,2,12</textarea>
           <br>
          \( F \) = <textarea id="entry_FactSelect_I" rows="1" cols="45" style="width: 90%">4,5,6,7,8,9,10,11,12,13,14</textarea>
          </p>
          <button onclick="runFunc('ans_actSelect_I','delay_actSelect_I','actSelect_I','entry_SactSelect_I','entry_FactSelect_I')" >Correr</button>
          <br>
          <br>
          <b>Salida:</b>
          <p>Conjunto más grande \( A \) de actividades compatibles.<br> Y tiempo de ejecución del algoritmo, sin contar llamadas u operaciones extras en JavaScript, excepto por el wrapper.<p>
          \( A: \; \)<b id="ans_actSelect_I"></b>
          <div id="delay_actSelect_I"></div>
        </td>
      </tr>
    </table>
  </div>


  <!-- ++++++++++++++++++++++++++++++++++++++++++++++++++ -->
  <!-- ++++++++++++++++++++++++++++++++++++++++++++++++++ -->
  <script>
    //var codes = ['a-code','b-code'];
    var codes = [];
    for(cod of codes){
      pseudocode.renderElement(document.getElementById( cod),{lineNumber: true, lineNumberPunc: ' ', noEnd: true});
    }
  </script>

</body>

<footer>
	Hecho por Salvador
</footer>

</html>