<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>Programación Dinamica</title>
	<link href="style.css" rel="stylesheet" type="text/css" />
	<style type="text/css">
  table{
    width: auto;
    margin: 0px;
    padding: 0px;
    border: 0px;
  }
  td{
    padding: 1px;
    width: auto;
  }
  th:empty, td:empty {
    border: 0;
    background:transparent;
  }
	</style>
	<script src="./p4_dinamica.js" type="module"></script>

	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

	<!-- https://www.npmjs.com/package/pseudocode -->
	<script>
		MathJax = {
        tex: {
            inlineMath: [['$','$'], ['\\(','\\)']],
            displayMath: [['$$','$$'], ['\\[','\\]']],
            processEscapes: true,
            processEnvironments: true,
        }
    }
	</script>
	<script src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/tex-chtml.js" integrity="sha256-3Fdoa5wQb+JYfEmTpQHx9sc/GuwpfC/0R9EpBki+mf8="
	 crossorigin>

	</script>
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.css">
	<script src="https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.js">

	</script>
</head>

<body>
	<h1>Programación Dinamica</h1>
	<br>
  <p>Aquí se encuentran algoritmos que resuelven problemas por medio de programación dinamica, la cual consiste en usar la informacion local para encontrar la solucion, la cual depende de cada paso.</p>
  <div class="toc_container">
    <h2 class="toc_title">Índice</h2>
    <ol class="toc">
      <li><a href="#scml">Subseccion común más larga (SCML)</a></li>
      <li><a href="#matrixChain">Orden de multiplicacion de matrices</a></li>
      <li><a href="#memCutRod">Problema de cortes con mayor ganancia</a></li>
      <!--
      <li><a href="#b">b</a></li>
      -->
    </ol>
  </div>
	<br>

  <div class="divSeparator"></div>
  <h2 id="scml">Subseccion común más larga (SCML)  <button onclick="hideShow('div_scml',this)" class="buttSpoiler">[ Ocultar ]</button></h2>
  <p>En este problema se quiere encontrar la subseccion mas larga de una cadena que se puede encontrar en otra.</p>
  <!-- +++++++ -->
  <div id="div_scml">
    <p>Se tienen dos algoritmos, uno que resuelve (LCS-LENGTH) y otro que imprime la cadena en orden(PRINT-LCS).</p>
    <h4>Descripción del algoritmo (LCS-LENGTH)</h4>
    <p>Este algoritmo busca la respuesta de la cadena. Tiene tiempo de ejecución: \( T(n) = \Theta (mn) \)</p>

    <h4>Pseudocódigo</h4>
    <img src="./i4_dinamica/lcs_length.PNG">
    <p>Código de (Cormen, 2001).</p>

    <h4>Fuente bibliográfica</h4>
    <p>Thomas H. Cormen, C. (2001). <em>Introduction to algorithms</em> (p. 394). The MIT Press.</p>

    <h4>Descripción del algoritmo (PRINT-LCS)</h4>
    <p>Este algoritmo imprime la subseccion solucion en orden. Tiene tiempo de ejecución: \( T(n) = \Theta (n+m) \)</p>

    <h4>Pseudocódigo</h4>
    <img src="./i4_dinamica/print_lcs.PNG">
    <p>Código de (Cormen, 2001).</p>

    <h4>Fuente bibliográfica</h4>
    <p>Thomas H. Cormen, C. (2001). <em>Introduction to algorithms</em> (p. 395). The MIT Press.</p>

    <h4>Implementación</h4>
    <p>Realizada en Javascript.</p>
    <b>Entrada:</b>
    <p>Recibe 2 listas con elementos a obtener la subseccion común más larga. No necesitan ser de mismo tamaño.<b>Nota: Hola.</b></p>
    <p>
    \( X \) = <textarea id="entry_Xscml" rows="1" cols="45" style="width: 90%">A,B,C,B,D,A,B</textarea>
      <br>
    \( Y \) = <textarea id="entry_Yscml" rows="1" cols="45" style="width: 90%">B,D,C,A,B,A</textarea>
    </p>
    <button onclick="runFunc('ans_scml','delay_scml','scml','entry_Xscml','entry_Yscml')" >Correr</button>
    <br>
    <br>
    <b>Salida:</b>
    <p>Matrices \( c \) y \( b\) que crean la solucion de la subseccion. Junto con la subseccion más larga.
    <br> Y tiempo de ejecución de LCS-LENGTH, PRINT-LCS y la impresion de todo al final sin contar llamadas u operaciones extras en JavaScript (dado que PRINT-LCS requiere \( b\)  esta es la mejor forma de correr todo y simplificar las operaciones al usuario).</p>
    <p>\( Respuesta \; \)</p>
    <br>
    <div id="ans_scml"></div>
    <div id="delay_scml"></div>
  </div>

  <!-- ++++++++++++++++++++++++++++++++++++++++++++++++++ -->
  <div class="divSeparator"></div>
  <h2 id="matrixChain">Orden de multiplicacion de matrices  <button onclick="hideShow('div_matrixChain',this)" class="buttSpoiler">[ Ocultar ]</button></h2>
  <p>La multiplicacion de matrices es una operacion cara especialmente cuando se trata de multiplicar varias matrices, por ello tiene mucha importancia el orden en que se multiplican para reducir el número de operaciones.</p>
  <!-- +++++++ -->
  <div id="div_matrixChain">
    <p>Se tienen dos algoritmos, uno que encuentra el mejor orden para multiplicar matrices(MATRIX-CHAIN-ORDER) y otro que lo imprime (PRINT-OPTIMAL-PARENTS).</p>
    <h4>Descripción del algoritmo (MATRIX-CHAIN-ORDER)</h4>
    <p>Este algoritmo busca el mejor orden de multiplicar matrices para hacer menos operaciones. Tiene tiempo de ejecución: \( T(n) = O (n^3) \)</p>

    <h4>Pseudocódigo</h4>
    <img src="./i4_dinamica/matrixChain.PNG">
    <p>Código de (Cormen, 2001).</p>

    <h4>Fuente bibliográfica</h4>
    <p>Thomas H. Cormen, C. (2001). <em>Introduction to algorithms</em> (p. 375). The MIT Press.</p>

    <h4>Descripción del algoritmo (PRINT-OPTIMAL-PARENTS)</h4>
    <p>Este algoritmo imprime las matrices y los parentesis en la forma que reducen el número de operaciones a realizar. Tiene tiempo de ejecución: \( T(n) = \Theta (n) \)</p>

    <h4>Pseudocódigo</h4>
    <img src="./i4_dinamica/printOptimal.PNG">
    <p>Código de (Cormen, 2001).</p>

    <h4>Fuente bibliográfica</h4>
    <p>Thomas H. Cormen, C. (2001). <em>Introduction to algorithms</em> (p. 377). The MIT Press.</p>

    <h4>Implementación</h4>
    <p>Realizada en Javascript.</p>
    <b>Entrada:</b>
    <p>Recibe 1 lista con los tamaños renglon, columna de las matrices a operar, claramente las matrices deben estar en el orden que les permitan multiplicarse.<b>Nota: No hay nota.</b><br>
    La imagen muestra el ejemplo que viene predeterminado.
    <img src="./i4_dinamica/exampleMatrixChain.PNG">
    </p>
    <p>
    \( p \) = <textarea id="entry_pMatrix" rows="1" cols="45" style="width: 90%">30,35,15,5,10,20,25</textarea>
    </p>
    <button onclick="runFunc('ans_matrixChain','delay_matrixChain','matrixChain','entry_pMatrix')" >Correr</button>
    <br>
    <br>
    <b>Salida:</b>
    <p>Matrices diagonales \( m \) y \( s \) que ilustran las operaciones en la solucion . Junto con las matrices y parentesis que separan el mejor orden de multiplicar.
    <br> Y tiempo de ejecución de LCS-LENGTH, PRINT-LCS y la impresion de todo al final sin contar llamadas u operaciones extras en JavaScript (dado que PRINT-LCS requiere \( b\)  esta es la mejor forma de correr todo y simplificar las operaciones al usuario).</p>
    <p>\( Respuesta \; \)</p>
    <div id="ans_matrixChain"></div>
    <div id="delay_matrixChain"></div>
  </div>

  
  <!-- ++++++++++++++++++++++++++++++++++++++++++++++++++ -->
  <div class="divSeparator"></div>
  <h2 id="memCutRod">Problema de cortes con mayor ganancia  <button onclick="hideShow('div_memCutRod',this)" class="buttSpoiler">[ Ocultar ]</button></h2>
  <p>Aqui se desea obtener la mejor ganancia segun cortes de distinta longitud en una vara, de las cuales cada corte tiene un precio distinto.</p>
  <!-- +++++++ -->
  <div id="div_memCutRod">
    <p>Se tienen dos algoritmos pero en sí solo se diferencian por que uno es el inicio y otro hace la llamada recursivo que es donde se busca la solucion.</p>
    <h4>Descripción del algoritmo</h4>
    <p>Busca que precio es mejor segun el subproblema de cortes de menor tamaño, pero usando memoria evita repetir subcortes ya calculados. Tiene tiempo de ejecución: \( T(n) = O (n^2) \)</p>

    <h4>Pseudocódigo</h4>
    <img src="./i4_dinamica/memoizedCutRod.PNG">
    <img src="./i4_dinamica/memoizedCutRodAux.PNG">
    <p>Código de (Cormen, 2001).</p>

    <h4>Fuente bibliográfica</h4>
    <p>Thomas H. Cormen, C. (2001). <em>Introduction to algorithms</em> (p. 365). The MIT Press.</p>

    <h4>Implementación</h4>
    <p>Realizada en Javascript.</p>
    <b>Entrada:</b>
    <p>Recibe 1 lista con los precios posibles segun el tamaño del corte, la longitud de este arreglo es el n que se toma automaticamente para iniciar el algoritmo (siendo que vender todo sin cortes es otro precio).<b>Nota: Listas largas pueden ser lentas por el tiempo de ejecución.</b>
    </p>
    <p>
    \( p \) = <textarea id="entry_memCutRod" rows="1" cols="45" style="width: 90%">1,5,8,9,10,17,17,20,24,30</textarea>
    </p>
    <button onclick="runFunc('ans_memCutRod','delay_memCutRod','memCutRod','entry_memCutRod')" >Correr</button>
    <br>
    <br>
    <b>Salida:</b>
    <p>Máxima ganancia posible para una vara con los precios marcados en cada tamaño de corte.
    <br> Tiempo de ejecución de MEMOIZED-CUT-ROD y el tiempo de todo el wrapper.</p>
    <p>\( Respuesta \; \)</p>
    <div id="ans_memCutRod"></div>
    <div id="delay_memCutRod"></div>
  </div>


  <!-- ++++++++++++++++++++++++++++++++++++++++++++++++++ -->
  <!-- ++++++++++++++++++++++++++++++++++++++++++++++++++ -->
  <script>
    //var codes = ['a-code','b-code'];
    var codes = [];
    for(cod of codes){
      pseudocode.renderElement(document.getElementById( cod),{lineNumber: true, lineNumberPunc: ' ', noEnd: true});
    }
  </script>

</body>

<footer>
	Hecho por Salvador
</footer>

</html>