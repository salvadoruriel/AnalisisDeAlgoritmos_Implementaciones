<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>Algoritmos recursivos e iterativos</title>
	<link href="style.css" rel="stylesheet" type="text/css" />
  <style type="text/css">
    th,td{
      width:50%
    }
  </style>
	<script src="./p2_recursiveIter.js" type="module"></script>
  
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>

  <!-- https://www.npmjs.com/package/pseudocode -->
  <script>
    MathJax = {
        tex: {
            inlineMath: [['$','$'], ['\\(','\\)']],
            displayMath: [['$$','$$'], ['\\[','\\]']],
            processEscapes: true,
            processEnvironments: true,
        }
    }
  </script> 
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/tex-chtml.js"
          integrity="sha256-3Fdoa5wQb+JYfEmTpQHx9sc/GuwpfC/0R9EpBki+mf8=" crossorigin>
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.css">
  <script src="https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.js">
  </script> 
</head>

<body>
	<h1>Algoritmos recursivos e iterativos</h1>
  <br>
  <p>Aquí se encuentran algoritmos que pueden completar una tarea de forma recursiva o iterativa. En ciertas ocasiones una solución es mejor que otra, a veces son iguales. Lo importante es identificar el método que mejor sirve para un problema.</p>
  <p>Para los algoritmos que requieren una lista de números pueden copiarse y pegarse listas mas grandes generadas en <a href='../p1_sorting.html'>Algoritmos de ordenacion</a>, solo considere si el algoritmo requiere una lista <b>ordenada</b> o no, pero de preferencia use la lista ordenada.</p>
  <div class="toc_container">
    <h2 class="toc_title">Índice</h2>
    <ol class="toc">
      <li><a href="#fact">Factorial</a></li>
      <li><a href="#power">Potencia</a></li>
      <li><a href="#fibonacci">Fibonacci</a></li>
      <li><a href="#lineal">Busqueda lineal</a></li>
      <li><a href="#binary">Busqueda binaria</a></li>
    </ol>
  </div>
	<br>

  <div class="divSeparator"></div>
  <h2 id="fact">Factorial <button onclick="hideShow('tab_fact',this)" class="buttSpoiler">[ Ocultar ]</button></h2>
  <!--<p style="margin-bottom: 999px;">Probando enlace insite-->
  <table align="center" id="tab_fact">
    <tr>
      <th><h3>Recursivo<h3></th>
      <th><h3>Iterativo<h3></th>
    </tr>
    <tr>
      <td>
        <h4>Descripción del algoritmo</h4>
        <p>Este algoritmo encuentra el factorial de un número \( n \) de forma recursiva. Tiene tiempo de ejecución: \( T(n) = \Theta(n) \)</p>

        <h4>Pseudocódigo</h4>
        <img src="./i2_recurIter/factorial_r.png" style="width:80%">
        <p>Fragmento de (Erickson, 2019), algoritmo similar a visto en clase (Rubio, 2020).</p>

        <h4>Fuente bibliográfica</h4>
        <!--https://es.wikihow.com/citar-apuntes-de-clase-->
        <p>Erickson, J. (2019). <em>Algorithms</em> (p.57). http://algorithms.wtf</p>
        <p>Rubio, Christian. "Metodo maestro y algoritmos recursivos." Analisis de algoritmos, 13 Oct. 2020. Universidad Nacional Autónoma de México. Clase.</p>

        <h4>Implementación</h4>
        <p>Realizada en Javascript. Valores grandes de n pueden causar infinito, pero no se hace lento el proceso.</p>
        <b>Entrada:</b>
        <p>El valor \( n \) de la operacion \( n! \) <b>Nota: Los negativos no estan considerados en el algoritmo.</b></p>
        n = <input type="text" id="nFact_R" value="5" size="2" maxlength="4"> 
        <button onclick="runFunc('nFact_R','ansFact_R','delayFact_R','fact_R')" >Correr</button>
        <br>
        <br>
        <b>Salida:</b>
        <p>Resultado de \( n! \).<br> Y tiempo de ejecución del algoritmo, sin contar llamadas u operaciones extras en JavaScript.<p>
        \( n!=\; \)<b id="ansFact_R"></b>
        <div id="delayFact_R"></div>
      </td><!-- ******************************************************** -->
      <td>
        <h4>Descripción del algoritmo</h4>
        <p>Este algoritmo encuentra el factorial de un número \( n \) de forma iterativa. Tiene tiempo de ejecución: \( T(n) = \Theta (n) \)</p>

        <h4>Pseudocódigo</h4>
        <pre id="fact-code" style="display:hidden;">
          % This algorithm is extracted from class
          \begin{algorithm}
          \caption{Factorial(n)}
          \begin{algorithmic}
            \STATE $x \leftarrow 1$
            \FOR{$i \gets 1$ \TO $n$}
              \STATE $x \leftarrow i*x$
            \ENDFOR
            \RETURN x
          \end{algorithmic}
          \end{algorithm}
        </pre>
        <p>Algoritmo visto en clase (Rubio, 2020), sin referencia exacta.</p>

        <h4>Fuente bibliográfica</h4>
        <p>Rubio, Christian. "Continuacion de algoritmos recursivos y bucle invariante." Analisis de algoritmos, 15 Oct. 2020. Universidad Nacional Autónoma de México. Clase.</p>

        <h4>Implementación</h4>
        <p>Realizada en Javascript. Valores grandes de n pueden causar infinito, pero no se hace lento el proceso.</p>
        <b>Entrada:</b>
        <p>El valor \( n \) de la operacion \( n! \) <b>Nota: Los negativos no estan considerados en el algoritmo.</b></p>
        n = <input type="text" id="nFact_I" value="5" size="2" maxlength="4"> 
        <button onclick="runFunc('nFact_I','ansFact_I','delayFact_I','fact_I')" >Correr</button>
        <br>
        <br>
        <b>Salida:</b>
        <p>Resultado de \( n! \).<br> Y tiempo de ejecución del algoritmo, sin contar llamadas u operaciones extras en JavaScript.<p>
        \( n!=\; \)<b id="ansFact_I"></b>
        <div id="delayFact_I"></div>
      </td>
    </tr>
  </table>

  <!-- ++++++++++++++++++++++++++++++++++++++++++++++++++ -->
  <div class="divSeparator"></div>
  <h2 id="power">Potencia <button onclick="hideShow('tab_Pot',this)" class="buttSpoiler">[ Ocultar ]</button></h2>
  <table align="center" id="tab_Pot">
    <tr>
      <th><h3>Recursivo<h3></th>
      <th><h3>Iterativo<h3></th>
    </tr>
    <tr>
      <td>
        <h4>Descripción del algoritmo</h4>
        <p>Este algoritmo eleva un número \( a \) a la potencia \( n \) deseada de forma recursiva. Tiene tiempo de ejecución: \( T(n) = \Theta (n) \)</p>

        <h4>Pseudocódigo</h4>
        <pre id="pow_R-code" style="display:hidden;">
          % This algorithm is extracted from class
          \begin{algorithm}
          \caption{Power(a,n)}
          \begin{algorithmic}
            \IF{$n=0$} 
              \RETURN 1;
            \ELSE 
              \RETURN $a*$\CALL{Power}{$a, n$}
            \ENDIF
          \end{algorithmic}
          \end{algorithm}
        </pre>
        <p>Algoritmo visto en clase (Rubio, 2020). Del cual no lo encontré en los libros Cormen ni Erickson, pero el algoritmo es bastante intuitivo.</p>

        <h4>Fuente bibliográfica</h4>
        <p>Rubio, Christian. "Metodo maestro y algoritmos recursivos." Analisis de algoritmos, 13 Oct. 2020. Universidad Nacional Autónoma de México. Clase.</p>

        <h4>Implementación</h4>
        <p>Realizada en Javascript.</p>
        <b>Entrada:</b>
        <p>Los valores enteros no negativos \( a \) y \(n \) de la operacion \( a^n \) <b>Nota: Valores grandes de \(n \) pueden causar error al alcanzar el maximo permitido de llamadas a funciones.</b></p>
        a = <input type="text" id="aPow_R" value="2" size="3" maxlength="5"> 
        n = <input type="text" id="nPow_R" value="3" size="2" maxlength="4"> 
        <button onclick="runFunc('aPow_R','ansPow_R','delayPow_R','pow_R','nPow_R')" >Correr</button>
        <br>
        <br>
        <b>Salida:</b>
        <p>Resultado de \( a^n \).<br> Y tiempo de ejecución del algoritmo, sin extras de JavaScript.<p>
        \( n!=\; \)<b id="ansPow_R"></b>
        <div id="delayPow_R"></div>
      </td><!-- ******************************************************** -->
      <td>
        <h4>Descripción del algoritmo</h4>
        <p>Este algoritmo eleva un número \( a \) a la potencia \( n \) deseada de forma iterativa. Tiene tiempo de ejecución: \( T(n) = \Theta (n) \)</p>

        <h4>Pseudocódigo</h4>
        <pre id="pow_I-code" style="display:hidden;">
          % This algorithm is created by me
          \begin{algorithm}
          \caption{Power-I(a,n)}
          \begin{algorithmic}
            \STATE $x \leftarrow 1$
            \FOR{$i \gets 1$ \TO $n$}
              \STATE $x \leftarrow a*x$
            \ENDFOR
            \RETURN x
          \end{algorithmic}
          \end{algorithm}
        </pre>
        <p>Algoritmo creado para satisfacer la comparación. Hay uno similar en (Erickson, 2019) pero no considera el 0.</p>

        <h4>Fuente bibliográfica</h4>
        <p>Erickson, J. (2019). <em>Algorithms</em> (p.43). http://algorithms.wtf</p>

        <h4>Implementación</h4>
        <p>Realizada en Javascript.</p>
        <b>Entrada:</b>
        <p>Los valores enteros no negativos \( a \) y \(n \) de la operacion \( a^n \)</p>
        a = <input type="text" id="aPow_I" value="2" size="3" maxlength="5"> 
        n = <input type="text" id="nPow_I" value="3" size="5" maxlength="9"> 
        <button onclick="runFunc('aPow_I','ansPow_I','delayPow_I','pow_I','nPow_I')" >Correr</button>
        <br>
        <br>
        <b>Salida:</b>
        <p>Resultado de \( a^n \).<br> Y tiempo de ejecución del algoritmo, sin extras de JavaScript.<p>
        \( n!=\; \)<b id="ansPow_I"></b>
        <div id="delayPow_I"></div>
      </td>
    </tr>
  </table>

  <!-- ++++++++++++++++++++++++++++++++++++++++++++++++++ -->
  <div class="divSeparator"></div>
  <h2 id="fibonacci">Fibonacci <button onclick="hideShow('tab_Fib',this)" class="buttSpoiler">[ Ocultar ]</button></h2>
  <table align="center" id="tab_Fib">
    <tr>
      <th><h3>Recursivo<h3></th>
      <th><h3>Iterativo<h3></th>
    </tr>
    <tr>
      <td>
        <h4>Descripción del algoritmo</h4>
        <p>Busca el \( n \)-esimo número Fibonacci ( \( F_n \) ) de forma recusiva. Tiene tiempo de ejecución: \( T(n) = O(1.62^n) \)</p>

        <h4>Pseudocódigo</h4>
        <pre id="fib_R-code" style="display:hidden;">
          % This algorithm is extracted from class
          \begin{algorithm}
          \caption{Fibonacci-R(n)}
          \begin{algorithmic}
            \IF{$n=0$} 
              \RETURN 0
            \ELSEIF{$n=1$}
              \RETURN 1
            \ELSE 
              \STATE $x \gets$ \CALL{Fibonacci-R}{$n-1$}
              \STATE $y \gets$ \CALL{Fibonacci-R}{$n-2$}
              \RETURN $x+y$
            \ENDIF
          \end{algorithmic}
          \end{algorithm}
        </pre>
        <p>Algoritmo visto en clase (Rubio, 2020).</p>

        <h4>Fuente bibliográfica</h4>
        <p>Rubio, Christian. "Continuacion de algoritmos recursivos y bucle invariante." Analisis de algoritmos, 15 Oct. 2020. Universidad Nacional Autónoma de México. Clase.</p>

        <h4>Implementación</h4>
        <p>Realizada en Javascript.</p>
        <b>Entrada:</b>
        <p>El \(n \)-esimo número de la <a href='https://web.archive.org/web/20201127014011/https://es.wikipedia.org/wiki/Sucesi%C3%B3n_de_Fibonacci'>serie fibonacci</a> a buscar. <b>Nota: Valores de \(n \) mayores a 40 son lentos, avance de 1 en 1 a partir de este valor, mas alla pueden congelar y causar errores.</b></p>
        n = <input type="text" id="nFib_R" value="8" size="1" maxlength="2"> 
        <button onclick="runFunc('nFib_R','ansFib_R','delayFib_R','fib_R')" >Correr</button>
        <br>
        <br>
        <b>Salida:</b>
        <p>El \( n \)-esimo número fibonacci.<br> Y tiempo de ejecución del algoritmo, sin extras de JavaScript.<p>
        \( F_n =\; \)<b id="ansFib_R"></b>
        <div id="delayFib_R"></div>
      </td><!-- ******************************************************** -->
      <td>
        <h4>Descripción del algoritmo</h4>
        <p>Busca el \( n \)-esimo número Fibonacci ( \( F_n \) ) de forma iterativa (en sí cuenta como programacion dinamica). Tiene tiempo de ejecución: \( T(n) = \Theta (n) \)</p>

        <h4>Pseudocódigo</h4>
        <pre id="fib_I-code" style="display:hidden;">
          % This algorithm is extracted from class
          \begin{algorithm}
          \caption{Fibonacci-I(n)}
          \begin{algorithmic}
            \IF{$n=0$} 
              \RETURN 0
            \ELSE 
              \STATE $x \gets 0$ 
              \STATE $y \gets 1$
              \FOR{$i \gets 1$ \TO $n-1$}
                \STATE $z \gets x+y$
                \STATE $x \gets y$
                \STATE $y \gets z$
              \ENDFOR
              \RETURN $y$
            \ENDIF
          \end{algorithmic}
          \end{algorithm}
        </pre>
        <p>Algoritmo visto en clase (Rubio, 2020), ligera adaptacion para visualizarse mejor en libreria de pseudocódigo.</p>

        <h4>Fuente bibliográfica</h4>
        <p>Rubio, Christian. "Continuacion de algoritmos recursivos y bucle invariante." Analisis de algoritmos, 15 Oct. 2020. Universidad Nacional Autónoma de México. Clase.</p>

        <h4>Implementación</h4>
        <p>Realizada en Javascript.</p>
        <b>Entrada:</b>
        <p>El \(n \)-esimo número de la <a href='https://web.archive.org/web/20201127014011/https://es.wikipedia.org/wiki/Sucesi%C3%B3n_de_Fibonacci'>serie fibonacci</a> a buscar. <b>Nota: Valores muy grandes de \(n \) marcan infinito.</b></p>
        n = <input type="text" id="nFib_I" value="8" size="2" maxlength="4"> 
        <button onclick="runFunc('nFib_I','ansFib_I','delayFib_I','fib_I')" >Correr</button>
        <br>
        <br>
        <b>Salida:</b>
        <p>El \( n \)-esimo número fibonacci.<br> Y tiempo de ejecución del algoritmo, sin extras de JavaScript.<p>
        \( F_n =\; \)<b id="ansFib_I"></b>
        <div id="delayFib_I"></div>
      </td>
    </tr>
  </table>
  
  <!-- ++++++++++++++++++++++++++++++++++++++++++++++++++ -->
  <div class="divSeparator"></div>
  <h2 id="lineal">Busqueda lineal <button onclick="hideShow('tab_busLin',this)" class="buttSpoiler">[ Ocultar ]</button></h2>
  <table align="center" id="tab_busLin">
    <tr>
      <th><h3>Recursivo<h3></th>
      <th><h3>Iterativo<h3></th>
    </tr>
    <tr>
      <td>
        <h4>Descripción del algoritmo</h4>
        <p>Este algoritmo busca linealmente un valor en un arreglo de números de forma recursiva. Tiene tiempo de ejecución: \( T(n) = \Theta (n) \)</p>
        <h4>Pseudocódigo</h4>
        <pre id="lin_R-code" style="display:hidden;">
          % This algorithm is extracted from class
          \begin{algorithm}
          \caption{Busqueda-Lineal-R(i,j,x)}
          \begin{algorithmic}
            \IF{$a_i=x$} 
              \RETURN $i$
            \ELSEIF{$i=j$} 
              \RETURN $\varnothing$
            \ELSE
              \RETURN \CALL{Busqueda-Lineal-R}{$i+1,j,x$}
            \ENDIF
          \end{algorithmic}
          \end{algorithm}
        </pre>
        <p>Algoritmo visto en clase (Rubio, 2020).</p>

        <h4>Fuente bibliográfica</h4>
        <p>Rubio, Christian. "Metodo maestro y algoritmos recursivos." Analisis de algoritmos, 13 Oct. 2020. Universidad Nacional Autónoma de México. Clase.</p>

        <h4>Implementación</h4>
        <p>Realizada en Javascript. Agregue el arreglo como argumento para facilitar la implementación, aprovechando que en javascript esto se realiza constante como referencia (o más bien paso por "sharing").</p>
        <b>Entrada:</b>
        <p>El valor \( x \) buscado en la lista de números "\( Arr \)" (separados por coma). <b>Nota: El arreglo no necesita estar en orden. Arreglos muy grandes pueden causar error al hacer busquedas muy extensas que superan el limite de hacer recursion.</b></p>
        x = <input type="text" id="xLineal_R" value="3" size="4" maxlength="9"> Arr=
        <textarea id="arrLineal_R" rows="3" cols="33" style="width: 100%">33,44,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32</textarea>
        <button onclick="runFunc('xLineal_R','ansLineal_R','delayLineal_R','lineal_R',toArr('arrLineal_R'))" >Correr</button>
        <br>
        <br>
        <b>Salida:</b>
        <p>Primer indice \( i \) (o posicion en el arreglo) donde se encontró el valor buscado, <b>iniciando desde 0</b>, <em>valor nulo significa que no esta el número en el arreglo</em>.<br> Y tiempo de ejecución del algoritmo, sin contar llamadas u operaciones extras en JavaScript.<p>
        \( i=\; \)<b id="ansLineal_R"></b>
        <div id="delayLineal_R"></div>
      </td><!-- ******************************************************** -->
      <td>
        <h4>Descripción del algoritmo</h4>
        <p>Este algoritmo busca linealmente un valor en un arreglo de números de forma iterativa. Tiene tiempo de ejecución: \( T(n) = \Theta (n) \)</p>
        <h4>Pseudocódigo</h4>
        <pre id="lin_I-code" style="display:hidden;">
          % This algorithm is mine
          \begin{algorithm}
          \caption{Busqueda-Lineal-I(x,i,j,a)}
          \begin{algorithmic}
            \FOR{$i$ \TO $j$}
              \IF{$a_i = x$}
                \RETURN $i$
              \ENDIF
            \ENDFOR
            \RETURN $\varnothing$
          \end{algorithmic}
          \end{algorithm}
        </pre>
        <p>Algoritmo creado para satisfacer la comparación. No hay otro similar en estas fuentes formales, pero es bastante intuitivo. Incluye \( a \) como el arreglo, siendo este pasado como referencia o valor similar que tiene tiempo constante. </p>

        <h4>Fuente bibliográfica</h4>
        <p>Aguirre, Salvador (Autor).</p>

        <h4>Implementación</h4>
        <p>Realizada en Javascript.</p>
        <b>Entrada:</b>
        <p>El valor \( x \) buscado en la lista de números "\( Arr \)" (separados por coma). <b>Nota: El arreglo no necesita estar en orden.</b></p>
        x = <input type="text" id="xLineal_I" value="3" size="4" maxlength="9"> Arr=
        <textarea id="arrLineal_I" rows="3" cols="33" style="width: 100%">33,44,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32</textarea>
        <button onclick="runFunc('xLineal_I','ansLineal_I','delayLineal_I','lineal_I',toArr('arrLineal_I'))" >Correr</button>
        <br>
        <br>
        <b>Salida:</b>
        <p>Primer indice \( i \) (o posicion en el arreglo) donde se encontró el valor buscado, <b>iniciando desde 0</b>, <em>valor nulo significa que no esta el número en el arreglo</em>.<br> Y tiempo de ejecución del algoritmo, sin contar llamadas u operaciones extras en JavaScript.<p>
        \( i=\; \)<b id="ansLineal_I"></b>
        <div id="delayLineal_I"></div>
      </td>
    </tr>
  </table>

  <!-- ++++++++++++++++++++++++++++++++++++++++++++++++++ -->
  <div class="divSeparator"></div>
  <h2 id="binary">Busqueda binaria <button onclick="hideShow('tab_busBin',this)" class="buttSpoiler">[ Ocultar ]</button></h2>
  <table align="center" id="tab_busBin">
    <tr>
      <th><h3>Recursivo<h3></th>
      <th><h3>Iterativo<h3></th>
    </tr>
    <tr>
      <td>
        <h4>Descripción del algoritmo</h4>
        <p>Este algoritmo busca un valor en un arreglo de números acortando el rango en el que esta el valor de forma recursiva. Tiene tiempo de ejecución: \( T(n) =\Theta (\lg n) \)</p>

        <h4>Pseudocódigo</h4>
        <pre id="bin_R-code" style="display:hidden;">
          % This algorithm is extracted from class
          \begin{algorithm}
          \caption{Busqueda-Binaria-R(x,i,j)}
          \begin{algorithmic}
            \STATE $m \gets \lceil \frac{i+j-1}{2} \rceil$
            \IF{$x=a_m$} 
              \RETURN m;
            \ELSEIF{$x < a_m$ \AND $i < m$} 
              \RETURN \CALL{Busqueda-Binaria-R}{$x, i, m-1$}
            \ELSEIF{$x > a_m$ \AND $j > m$}
              \RETURN \CALL{Busqueda-Binaria-R}{$x, m+1, j$}
            \ELSE
              \RETURN $\varnothing$
            \ENDIF
          \end{algorithmic}
          \end{algorithm}
        </pre>
        <p>Algoritmo visto en clase (Rubio, 2020).</p>

        <h4>Fuente bibliográfica</h4>
        <p>Rubio, Christian. "Continuacion de algoritmos recursivos y bucle invariante." Analisis de algoritmos, 15 Oct. 2020. Universidad Nacional Autónoma de México. Clase.</p>

        <h4>Implementación</h4>
        <p>Realizada en Javascript. Agregue el arreglo como argumento para facilitar la implementación, aprovechando que en javascript esto se realiza constante como referencia (o más bien paso por "sharing").</p>
        <b>Entrada:</b>
        <p>El valor \( x \) buscado en la lista de números "\( Arr \)" (separados por coma). <b>Nota: El arreglo DEBE estar en orden.</b></p>
        x = <input type="text" id="xBinaria_R" value="3" size="4" maxlength="9"> Arr=
        <textarea id="arrBinaria_R" rows="3" cols="33" style="width: 100%">1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,44</textarea>
        <button onclick="runFunc('xBinaria_R','ansBinaria_R','delayBinaria_R','binary_R',toArr('arrBinaria_R'))" >Correr</button>
        <br>
        <br>
        <b>Salida:</b>
        <p>Primer indice \( i \) (o posicion en el arreglo) donde se encontró el valor buscado, <b>iniciando desde 0</b>, <em>valor nulo significa que no esta el número en el arreglo</em>.<br> Y tiempo de ejecución del algoritmo, sin contar llamadas u operaciones extras en JavaScript.<p>
        \( i=\; \)<b id="ansBinaria_R"></b>
        <div id="delayBinaria_R"></div>
      </td><!-- ******************************************************** -->
      <td>
        <h4>Descripción del algoritmo</h4>
        <p>Este algoritmo busca un valor en un arreglo de números acortando el rango en el que esta el valor de forma iterativa. Tiene tiempo de ejecución: \( T(n) =\Theta (\lg n) \)</p>

        <h4>Pseudocódigo</h4>
        <pre id="bin_I-code" style="display:hidden;">
          % This algorithm is mine
          \begin{algorithm}
          \caption{Busqueda-Binaria-I(x,i,j,a)}
          \begin{algorithmic}
            \WHILE{$i \leq j$}
              \STATE $mitad \gets \lfloor \frac{i+j}{2} \rfloor$
              \IF{$x=a_{mitad}$} 
                \RETURN $mitad$
              \ENDIF
              \IF{$x > a_{mitad}$} 
                \STATE $i \gets mitad+1$
              \ELSE
                \STATE $j \gets mitad-1$
              \ENDIF
            \ENDWHILE
            \RETURN NIL
          \end{algorithmic}
          \end{algorithm}
        </pre>
        <p>Algoritmo creado para satisfacer la comparación y por aparecer como tarea en (Cormen, 2001) .</p>

        <h4>Fuente bibliográfica</h4>
        <p>Thomas H. Cormen, C. (2001). <em>Introduction to algorithms</em>. The MIT Press.</p>

        <h4>Implementación</h4>
        <p>Realizada en Javascript.</p>
        <b>Entrada:</b>
        <p>El valor \( x \) buscado en la lista de números "\( Arr \)" (separados por coma). <b>Nota: El arreglo DEBE estar en orden.</b></p>
        x = <input type="text" id="xBinaria_I" value="3" size="4" maxlength="9"> Arr=
        <textarea id="arrBinaria_I" rows="3" cols="33" style="width: 100%">1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,44</textarea>
        <button onclick="runFunc('xBinaria_I','ansBinaria_I','delayBinaria_I','binary_I',toArr('arrBinaria_I'))" >Correr</button>
        <br>
        <br>
        <b>Salida:</b>
        <p>Primer indice \( i \) (o posicion en el arreglo) donde se encontró el valor buscado, <b>iniciando desde 0</b>, <em>valor nulo significa que no esta el número en el arreglo</em>.<br> Y tiempo de ejecución del algoritmo, sin contar llamadas u operaciones extras en JavaScript.<p>
        \( i=\; \)<b id="ansBinaria_I"></b>
        <div id="delayBinaria_I"></div>
      </td>
    </tr>
  </table>

  <script>
    var codes = ['fact-code','pow_R-code','pow_I-code','fib_R-code','fib_I-code','lin_R-code','lin_I-code','bin_R-code','bin_I-code'];
    for(cod of codes){
      pseudocode.renderElement(document.getElementById( cod),{lineNumber: true, lineNumberPunc: ' ', noEnd: true});
    }
  </script>

</body>

<footer>
	Hecho por Salvador
</footer>

</html>